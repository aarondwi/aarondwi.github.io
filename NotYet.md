# Not Yet, if ever

## technical

1. Distributed Tracing is basically best-effort distributed transactions, one to do the work, one to log
2. Sensible default, but configurable
3. Kubernetes because google buys a big enough hardware for only one app
4. "Lots of features" is good for services, "do one `large` thing (business functionality) well" is good for libraries
5. Is "infra as code" a code? If yes, how to test it?
6. Code to write VS to learn, or why big framework/abstraction is bad
7. Isolation in ACID is a very, very insanely expensive illusion
8. Async RPC framework is (mostly) useless, if not harmful
9. SLAs are kinda weird (better violating or just downtime?), which better be split into `soft` SLA and `hard` SLA
10. Automate for sake of automating?
11. There is always a place for middle value (memory vs NVM vs SSD vs HDD, GC + pool vs pure GC vs pure manual, all memory vs buffer manager vs wisckey, electron/react native/flutter, etc)
12. Tree structure as a model of concurrency among business entities
13. Simplicity by using the simplest silver bullet

## non-technical

1. Stupid tech decisions and politics opening lots of new companies and job markets, and should be hyped even more
2. `Machine is cheap, dev is expensive` mantra only apply to countries with broken high salary
